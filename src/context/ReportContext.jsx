import React, { createContext, useContext, useState, useEffect } from 'react';
import { supabase } from '../lib/supabaseClient';
import { formatReportData } from '../utils/reportUtils';

const ReportContext = createContext();

export const useReports = () => useContext(ReportContext);

export const ReportProvider = ({ children }) => {
    const [reports, setReports] = useState([]);
    const [isLoading, setIsLoading] = useState(true);

    // Fetch reports function (exposed for silent sync)
    const fetchAnalysis = async (userId) => {
        setIsLoading(true);
        try {
            console.log("[ReportContext] Fetching reports for User ID:", userId);

            const { data, error } = await supabase
                .from('code_submit')
                .select('*')
                .eq('user_id', userId)
                .order('created_at', { ascending: false });

            if (error) throw error;

            if (data && data.length > 0) {
                console.log("[ReportContext] Raw Supabase Data:", data);
                const formattedReports = data.map(item => formatReportData(item));
                setReports(formattedReports);
            } else {
                console.log("[ReportContext] No reports found for user");
                setReports([]);
            }
        } catch (error) {
            console.error("[ReportContext] Error fetching reports:", error);
        } finally {
            setIsLoading(false);
        }
    };

    // Initialize reports based on auth state changes
    useEffect(() => {
        let mounted = true;

        // 1. Check active session immediately on mount
        supabase.auth.getSession().then(({ data: { session } }) => {
            if (mounted) {
                if (session?.user) {
                    console.log("[ReportContext] Initial session found:", session.user.id);
                    fetchAnalysis(session.user.id);
                } else {
                    console.log("[ReportContext] No initial session found via getSession");
                    setIsLoading(false);
                }
            }
        });

        // 2. Listen for auth state changes
        const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
            console.log("[ReportContext] Auth state changed:", _event, session?.user?.id);
            if (session?.user) {
                fetchAnalysis(session.user.id);
            } else {
                if (mounted) {
                    setReports([]);
                    setIsLoading(false);
                }
            }
        });

        return () => {
            mounted = false;
            subscription.unsubscribe();
        };
    }, []);

    // Add new report with DB Persistence
    const addReport = async (newReportData) => {
        // 1. Optimistic Update (Immediate UI feedback)
        const formattedReport = formatReportData(newReportData);
        console.log("[ReportContext] Optimistically adding report:", formattedReport);
        setReports((prev) => [formattedReport, ...prev]);

        // 2. Persist to DB (Background)
        try {
            const { data: { session } } = await supabase.auth.getSession();
            if (!session?.user) {
                console.warn("[ReportContext] User not logged in, cannot save to DB");
                return formattedReport;
            }

            // Prepare payload - Assuming API keys match DB columns mostly
            // We need to map if they don't, but based on logs they seem to be snake_case.
            // CAUTION: 'id' might be auto-generated by DB. We shouldn't send it if it confuses DB, 
            // but we might need it for local state.
            // Let's rely on Supabase to generate ID and created_at if missing.

            const payload = {
                user_id: session.user.id,
                ...newReportData,
                // Ensure critical fields are present
                lang: newReportData.lang || 'javascript',
                // If API returns 'problem', 'ai_code', etc. make sure they map to DB columns
                // Assuming DB columns: problem_code, solution_code (wait, check Submit.jsx or API)
                // Submit.jsx sends: problemCode, solutionCode, lang to API.
                // API returns: problem, ai_code, etc. as per formatReportData.
                // We might need to check if DB columns match exactly.
                // For now, we dump the API response. If DB rejects, we'll see error.
            };

            // Remove 'id' if it's a temp timestamp from API, let DB handle it?
            // Actually, formatReportData generates a timestamp ID.
            delete payload.id;
            delete payload.created_at;

            console.log("[ReportContext] Persisting to DB:", payload);
            const { error } = await supabase.from('code_submit').insert([payload]);

            if (error) {
                console.error("[ReportContext] DB Insert Error:", error);
                // Optionally rollback optimistic update? 
                // For now, keep it to show user the result.
            } else {
                console.log("[ReportContext] DB Insert Success");
            }
        } catch (err) {
            console.error("[ReportContext] Persistence Failed:", err);
        }

        return formattedReport;
    };

    // Refresh function for Silent Sync
    const refreshReports = async () => {
        const { data: { session } } = await supabase.auth.getSession();
        if (session?.user) {
            // We want to update silently, so maybe don't set isLoading to true?
            // User requested "Invisible Refresh".
            console.log("[ReportContext] Silent Refresh triggered");

            const { data, error } = await supabase
                .from('code_submit')
                .select('*')
                .eq('user_id', session.user.id)
                .order('created_at', { ascending: false });

            if (!error && data) {
                const formattedReports = data.map(item => formatReportData(item));
                setReports(formattedReports);
            }
        }
    };

    const getReportById = (id) => reports.find(r => r.id === id);

    return (
        <ReportContext.Provider value={{ reports, addReport, getReportById, isLoading, refreshReports }}>
            {children}
        </ReportContext.Provider>
    );
};
